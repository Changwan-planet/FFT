Program FFT
IMPLICIT NONE

!INPUT DATA & INITIALIZATION
INTEGER,PARAMETER :: S=32   !THE NUMBER OF SAMPLE POINT
INTEGER           :: N=S        !THE NUMBER OF SAMPLE POINT FOR DO LOOP   
REAL*8, PARAMETER :: pi=Acos(-1.0)
INTEGER           :: K        !SAMPLE POINT

INTEGER :: N2                 !THE SPACING BETWEEN DUAL NODES

INTEGER :: NU                 !GAMMA 
INTEGER :: L                  !GAMMA FOR DO LOOP (ARRAY NUMBER BEING CONSIDERED)                 

INTEGER :: P
INTEGER :: P_INTEGER
INTEGER :: NU1                !THE NU1 IS THE RIGHT SHIFT REQUIRED WHEN DETERMINING THE VALUE OF P.
INTEGER :: I                  !THIS COUNTER MONITORS THE NUMBER OF DUAL NODE PAIRS THAT HAVE BEEN CONSIDERED.                                            !THE COUNTER I IS THE CONTROL FOR DETERMINING WHEN THE PROGRAM MUST SKIP.
INTEGER :: I_INTEGER
 

!REAL*8, PARAMETER :: JEX=-2*pi/S
REAL*8 :: ARG
REAL*8, DIMENSION(S) :: XREAL
REAL*8, DIMENSION(S) :: XIMAG
REAL*8 :: TREAL
REAL*8 :: TIMAG
REAL*8 :: CC
REAL*8 :: SS


REAL*8 :: T1  !TEMPORARY VALUE
REAL*8 :: T3  !TEMPORARY VALUE
INTEGER :: T4 !TEMPORARY VALUE

!INTEGER :: BD !BINARY DIGIT
INTEGER :: t, br, CT, Y, Z, ALLOCATESTATUS
INTEGER, PARAMETER :: BS =32
INTEGER, DIMENSION(BS) :: K_BINARY
INTEGER, DIMENSION(BS) :: K_BINARY_SCALED
INTEGER, DIMENSION(BS) :: K_BINARY_SCALED_REVERSED
INTEGER, DIMENSION(BS) :: I_BINARY
INTEGER, DIMENSION(BS) :: I_BINARY_REVERSED

INTEGER :: f

OPEN(10, FILE="sine_testFFT.txt", status='replace')
OPEN(11, FILE="output_testFFT.txt",status='replace')

f=1
XREAL=0

Do t=0, S-1

   XREAL(t)=cos(2*pi*f*(t)/(S-1))

   WRITE(10,*) XREAL(t)

END DO 
 
NU = 0
T1 = 0
T3 = 0 
K = 0
L = 1
!BD = 0
T4 = 0
   
DO 

  IF (N==1) EXIT

  N=INT(N/2)
  NU=NU+1

END DO

NU1 = NU - L
N2 = S / 2**(L)

T4 = S-1   

!THE LAST VALUE OF THE K! I NEED THIS VALUE TO GET THE DIGIT OF 
!THE MOST LARGE BINARY VALUE IN THIS CALCUATION.

150 IF(L<=NU) THEN
 
140      I=1
      
130      CALL INTEGER2BINARY(K,NU,K_BINARY)
         CALL SCALE2RIGHT(K_BINARY,NU1,K_BINARY_SCALED)
         CALL REVERSED_BINARY(K_BINARY_SCALED,K_BINARY_SCALED_REVERSED)  
         CALL BINARY2INTEGER(K_BINARY_SCALED_REVERSED,P_INTEGER)
         
         ARG = 2*pi*P_INTEGER/S
 
         CC = COS(ARG)
         SS = SIN(ARG)
      
         TREAL = XREAL(K+N2) * CC + XIMAG(K+N2) * SS
         TIMAG = XIMAG(K+N2) * CC - XREAL(K+N2) * SS    

         XREAL(K+N2) = XREAL(K) - TREAL
         XIMAG(K+N2) = XIMAG(K) - TIMAG
         XREAL(K) = XREAL(K) + TREAL
         XIMAG(K) = XIMAG(K) + TIMAG
                
         K=K+1   !GO TO THE NEXT NODE
         
          IF(I==N2) THEN
           
              K = K + N2
              
              IF (K < S-1) THEN
                  GO TO 140              
            
              ELSE 

                  L = L+1
                  N2 = N2/2
                  NU1 = NU1 -1
                  K = 0
                  GO TO 150
              
              END IF   
                 
          ELSE

             I=I+1

             GO TO 130

           END IF    

    ELSE 
      
200    CALL INTEGER2BINARY(K,NU,I_BINARY)           
       CALL REVERSED_BINARY(I_BINARY,I_BINARY_REVERSED)
       CALL BINARY2INTEGER (I_BINARY_REVERSED,I_INTEGER)
             
        IF (I_INTEGER < K) THEN
            GO TO 300         
        ELSE
           
            TREAL = XREAL(K)
            TIMAG = XIMAG(K)

            XREAL(K) = XREAL(I_INTEGER)
            XIMAG(K) = XIMAG(I_INTEGER)
            XREAL(I_INTEGER) = TREAL
            XIMAG(I_INTEGER) = TIMAG

            GO TO 300
                   
        END IF
            
300      IF (K==(S-1)) THEN
            DO Z=0, S-1

!               PRINT "(a,i4,a,f20.16,4X,a,i4,a,f20.16)", "XREAL(",Z,")=",&
!                     XREAL(Z),"XIMAG(",Z,")=",XIMAG(Z)      
              WRITE(11,*) XREAL(Z),XIMAG(Z)
            END DO
             
             STOP

         ELSE

             K =  K+1
             GO TO 200
           
         END IF

    END IF


STOP

CONTAINS

SUBROUTINE INTEGER2BINARY(I,NU,B) 
IMPLICIT NONE
    INTEGER, INTENT(IN) :: I
    INTEGER, INTENT(IN) :: NU
    INTEGER, DIMENSION (:), INTENT(OUT) :: B
    INTEGER :: C,J,L

    B = 0 
    J = I
    
    DO C=NU,1,-1
    
       IF(MOD(J,2)==0) THEN
         B(C) = 0
       
       ELSE
         B(C) = 1
       END IF

       J=J/2 !NOTICE THE USE OF TRUNCATED RESULT

       IF (J==0) THEN
          EXIT
       END IF

    END DO
 
END SUBROUTINE INTEGER2BINARY
    
SUBROUTINE SCALE2RIGHT(K_BINARY,NU1,K_BINARY_SCALED)
    INTEGER, INTENT(IN) :: NU1
    INTEGER, DIMENSION(:) :: K_BINARY
    INTEGER, DIMENSION(:), INTENT(OUT) :: K_BINARY_SCALED
    INTEGER :: I,J,K,T,L
   
    I=0
    J=1
    T=0
     
    T=SIZE(K_BINARY)-NU1
   
    DO J=1,T
     
       K_BINARY_SCALED(J+NU1)=K_BINARY(J)       
    
    END DO

    DO L=1,NU1
       K_BINARY_SCALED(L)=0
    END DO

END SUBROUTINE

SUBROUTINE REVERSED_BINARY(K_BINARY_SCALED,K_BINARY_SCALED_REVERSED)
IMPLICIT NONE

INTEGER, DIMENSION(:) :: K_BINARY_SCALED
INTEGER, DIMENSION(:), INTENT(OUT) :: K_BINARY_SCALED_REVERSED
INTEGER :: I,CT,NU
     
        DO I=1,SIZE(K_BINARY_SCALED)
       
          K_BINARY_SCALED_REVERSED(SIZE(K_BINARY_SCALED)+1-I) = K_BINARY_SCALED(I)
       
        END DO
    
END SUBROUTINE


SUBROUTINE BINARY2INTEGER(K_BINARY_SCALED_REVERSED, P_INTEGER)
IMPLICIT NONE

INTEGER,DIMENSION(:) :: K_BINARY_SCALED_REVERSED
INTEGER, INTENT(OUT) :: P_INTEGER
INTEGER :: I,J

P_INTEGER=0
   
    DO J=1,SIZE(K_BINARY_SCALED_REVERSED)

       P_INTEGER=P_INTEGER+K_BINARY_SCALED_REVERSED(J)*2**(SIZE(K_BINARY_SCALED_REVERSED)-J) 

    END DO

END SUBROUTINE

END PROGRAM FFT
